---
title: "logLik MCMC calc"
author: "Hillary Heiling"
date: "September 21, 2019"
output: html_document
---

# Materials needed for calculation

```{r}
library(glmmPen)
library(lme4)

M = 10^4

# Running fit_dat

dat = sim.data2(n = 500, ptot = 2, pnonzero = 2, nstudies = 10, sd_raneff = 1.0, 
                family = 'binomial', slopes = T, seed = 1618, imbalance = 1, pnonzerovar = 0, 
                beta = c(0, 2, 2))

out_fit = fit_dat(dat, nMC = 100, family = "binomial", nMC_max = 2000, gibbs = F)

# Set gibbs = T because output of out_fit showed permanently switched from rejection 
# sampling to gibbs sampling
post_list = sample.mc2(fit = out_fit$fit, cov = out_fit$sigma, y = dat$y, X = dat$X,
                      Z = out_fit$extra$Znew2, nMC = M, family = "binomial", 
                      group = dat$group, d = nlevels(dat$group), okindex = out_fit$extra$ok_index,
                      nZ = out_fit$extra$Znew2, gibbs = T, uold = out_fit$u)

post_U = post_list$u0

# Getting glmer estimate

data_test = data.frame(y = dat$y, dat$X[,-1], group = dat$group)

fit_glmer = glmer(formula = y ~ X1 + X2 + (X1 + X2 | group), data = data_test, family = "binomial")

# Target value:
(ll_glmer = logLik(fit_glmer))

```

ACF plot:

```{r}
library(ggplot2)
group = dat$group
grp_names = as.numeric(levels(group))
d = nlevels(group)
var_names = c("Intercept","X1","X2")
var_num = length(var_names)
grp_index = rep(grp_names, times = var_num)
var_index = rep(var_names, each = d)
U_keep = post_U

for(j in 1:ncol(U_keep)){
  ACF = acf(U_keep[,j], plot=F, lag.max = 30)
  ACF_df = with(ACF, data.frame(lag,acf))
  ACF_df$grp_names = grp_index[j]
  ACF_df$var_names = var_index[j]
  if(j == 1){
    ACF_all = ACF_df
  }else{
    ACF_all = rbind(ACF_all, ACF_df)
  }
}

plot_acf = ggplot(data = ACF_all, mapping = aes(x = lag, y = acf)) +
  geom_hline(mapping = aes(yintercept = 0)) + 
  geom_segment(mapping = aes(xend = lag, yend = 0)) +
  facet_grid(var_names ~ grp_names)

plot_acf
```

For this particular example, it seems thinning to every 20th draw is sufficient for indpenedent posterior samples.

# Anna Pajor Method - (IS) CAME

Functions:

```{r}
library(mvtnorm)

indicator = function(bounds, samples){
  inbounds = function(x){mean(x > bounds[1,] & x < bounds[2,]) == 1}
  apply(samples, 1, inbounds)
}

CAME_IS = function(post_draws, y, X, Z, group, coef, sigma, family, M){
  
  # Thin posterior draws
  ## See acf plot: seems okay for this example to thin by 20
  thin = seq(from = 1, to = nrow(post_draws), by = 20)
  posterior = post_draws[thin,]
  
  # Define variables
  d = nlevels(group)
  num_var = ncol(Z) / d
  Gamma = t(chol(sigma))
  eta_fef = X %*% coef[1:ncol(X)]
  post_mean = colMeans(posterior)
  
  # Calculate bounds of the posterior for each dimension
  bounds = apply(posterior, 2, range)
  
  ll = 0
  
  for(k in 1:d){
    # Define group-specific individuals
    ids = (group == k)
    y_k = y[ids]
    n_k = sum(ids)
    
    # Identify columns corresponding to group k
    cols = seq(from = k, by = d, length.out = num_var)
    Z_k = Z[ids,cols]
    
    # Sample M samples from the importance function
    ## Importance function: multivariate normal (multivariate t?)
    post_cov = cov(posterior[,cols])
    imp_samp = rmvnorm(M, mean = post_mean[cols], sigma = post_cov)
    # imp_samp = rmvnorm(M, mean = post_mean[cols], sigma = sigma)
    # imp_samp = rmvt(M, df = 10, delta = post_mean[cols], sigma = sigma)
    
    # Determine Importance Weights - f/g
    prior = dmvnorm(imp_samp) # Mean 0, sigma I
    imp_dens = dmvnorm(imp_samp, post_mean[cols], sigma = post_cov)
    # imp_dens = dmvt(imp_samp, delta = post_mean[cols], sigma = sigma, df = 10, log = F)
    wt = prior / imp_dens
    
    # Calculate density given importance samples
    
    ## Fixed-effects component of eta (linear predictor)
    eta_fef_k = matrix(eta_fef[ids], nrow = 1) # 1 X n_k
    ## Random-effects component of eta (linear predictor)
    eta_ref = imp_samp %*% Gamma %*% t(Z_k) # M x n_k
    ### Question: should Gamma here be t(chol(post_cov)) instead of t(chol(sigma))?
    ## Full eta - fixed + random effects component
    eta = eta_fef_k[rep(1, M),] + eta_ref
    
    # Calculate indicator function
    indic = indicator(bounds[,cols], imp_samp)
    cat("proportion of samples inside bounds:", mean(indic), "\n")
    
    if(family == "binomial"){
      prob_mat = exp(eta) / (1+exp(eta))
      # Columns of prob_mat correspond to individuals
      for(i in 1:n_k){
        dens = dbinom(y_k[i], size = 1, prob = prob_mat[,i], log = F)
        lik_i = mean(dens*indic*wt)
        ll_i = log(lik_i)
        ll = ll + ll_i
      } # End i loop
    }else{
      stop("specified family not currently available")
    }
    
  } # End k loop

  return(ll)
} # End CAME_IS function

# Sample from prior, no importance sampling
CAME = function(posterior, y, X, Z, group, coef, sigma, family, M){
  
  # Define variables
  d = nlevels(group)
  num_var = ncol(Z) / d
  Gamma = t(chol(sigma))
  eta_fef = X %*% coef[1:ncol(X)]
  # post_mean = colMeans(posterior)
  # post_cov = sigma
  
  # Calculate bounds of the posterior for each dimension
  bounds = apply(posterior, 2, range)
  
  ll = 0
  
  for(k in 1:d){
    # Define group-specific individuals
    ids = (group == k)
    y_k = y[ids]
    n_k = sum(ids)
    
    # Identify columns corresponding to group k
    cols = seq(from = k, by = d, length.out = num_var)
    Z_k = Z[ids,cols]
    
    # Sample M samples from the prior function
    zero = rep(0, num_var)
    I = diag(x = 1, nrow = num_var)
    prior = rmvnorm(M, zero, I) # Mean 0, sigma I
    
    # Calculate density given importance samples
    
    ## Fixed-effects component of eta (linear predictor)
    eta_fef_k = matrix(eta_fef[ids], nrow = 1)
    ## Random-effects component of eta (linear predictor)
    eta_ref = prior %*% Gamma %*% t(Z_k)
    ## Full eta - fixed + random effects component
    eta = eta_fef_k[rep(1, M),] + eta_ref
    
    # Calculate indicator function
    indic = indicator(bounds[,cols], prior)
    cat("proportion of samples inside bounds:", mean(indic), "\n")
    
    if(family == "binomial"){
      prob_mat = exp(eta) / (1+exp(eta))
      for(i in 1:n_k){
        dens = dbinom(y_k[i], size = 1, prob = prob_mat[,i], log = F)
        lik_i = mean(dens*indic)
        ll_i = log(lik_i)
        ll = ll + ll_i
      } # End i loop
    }else{
      stop("specified family not currently available")
    }
    
  } # End k loop

  return(ll)
} # End CAME function
```

Testing of functions:

```{r}
# logLik estimates:

# IS CAME - group covariance calculated
(ll_test = CAME_IS(post_draws = post_U, y = dat$y, X = dat$X, Z = dat$Z, 
                group = dat$group, coef = out_fit$coef, sigma = out_fit$sigma, 
                family = "binomial", M = 10^5))

# CAME
(ll_test2 = CAME(posterior = post_U, y = dat$y, X = dat$X, Z = dat$Z, 
                group = dat$group, coef = out_fit$coef, sigma = out_fit$sigma, 
                family = "binomial", M = 10^4))

ll_glmer
ll_test
ll_test2
```

# Raftery et al Method 2 (Section 2)

Note: I may be misinterpretting what the $\ell_t$ should be in this case.

```{r}
ll_S4 = function(posterior, y, X, Z, group, coef, sigma, family){
  
  # Define variables
  d = nlevels(group)
  q = ncol(Z) / d # Number of variables
  Gamma = t(chol(sigma))
  
  # # Thin posterior
  # thinned = seq(from = 1, to = nrow(post), by = 30)
  # posterior = post[thinned,]
  M = nrow(posterior)
  
  ll = 0
  
  for(k in 1:d){
    # Identify individuals from group k
    ids = (group == k)
    y_k = y[ids]
    X_k = X[ids,]
    
    # Identify columns of posterior and Z pertaining to group k
    cols = seq(from = k, by = d, length.out = q)
    U = posterior[,cols]
    Z_k = Z[ids,cols]
    
    # Calculate eta
    ## Fixed effects contribution
    eta_fef = matrix(X_k %*% coef[1:ncol(X)], nrow = 1) # 1 x n_k
    ## Random effects contribution
    eta_ref = U %*% Gamma %*% t(Z_k) # M x n_k
    ## Full: fixed + random effects contributions
    eta = eta_fef[rep(1,times = M),] + eta_ref
    
    n_k = sum(ids)
    logdens = matrix(0, nrow = M, ncol = n_k)
    
    for(i in 1:n_k){
      # Calculate ll_t
      if(family == "binomial"){
        p = exp(eta[,i]) / (1+exp(eta[,i]))
        p = ifelse(p < 10^-16, 10^-16, p)
        p = ifelse(p > (1-10^-16), (1-10^-16), p)
        logdens[,i] = dbinom(y_k[i], size = 1, prob = p, log = T)
      }else if(family == "poisson"){
        stop("'poisson' option not yet available")
      }

    } # End i loop
    
    
    ll_t = rowSums(logdens)
    ll_bar = mean(ll_t)
    # s_l = var(ll_t)
    # cat("estimate of q:", s_l*2, "\n")
    s_l = q/2 # for indep samples, s_l = var(ll_t)
    
    ll_k = ll_bar - s_l * (log(n_k) - 1)
    ll = ll + ll_k
    
  } # End k loop
  
  return(ll)
  
} # End ll_S4 function
```

Testing of ll_S4

```{r}
# logLik estimates:
(ll_test = ll_S4(posterior = post_U, y = dat$y, X = dat$X, Z = dat$Z, 
                group = dat$group, coef = out_fit$coef, sigma = out_fit$sigma, family = "binomial"))
  # posterior, y, X, Z, group, coef, sigma, family

ll_glmer
ll_test
```


The End